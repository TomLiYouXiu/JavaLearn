# 常用简单DOS命令

~~~bash
#盘符切换
#查看当前目录下的文件 dir
#切换目录 cd
cd ..
#清理屏幕 cls(clear screen)
#退出终端 exit
#查看电脑IP ipconfig
#打开应用
	calc 计算器
	mspaint 画图
	notepad 记事本
#ping 命令
	ping
#文件操作
	md 目录名 创建目录
	rd 目录名 删除目录
	cd>文件名 创建文件
	del文件名 删除文件

~~~

# Java基础

## 注释

~~~java
//书写注释是非常好的习惯
//单行注释  //
//多行注释 /* */
//JavaDoc:文档注释 /** */
//平时写代码一定要注意规范
~~~

## 标识符

1. 标识符由字母、数字、下划线“_”、汉字、美元符号“$”组成，第一个字符不能是数字。
2. 不能把[java关键字](https://baike.baidu.com/item/java关键字)和[保留字](https://baike.baidu.com/item/保留字)作为标识符。
3. 标识符没有长度限制。
4. 标识符对大小写敏感

## 数据类型

~~~java
 		//整数
        int num1=10; //最常用
        byte num2=20;
        short num3=20;
        long num4=20L; //为了区分long一般加上L

        //小数 ：浮点数
        float num5=40.5F; //为了区分float一般再加上F
        double num6=3.1415926;

        //字符
        char name ='A';
        //字符串，String不是关键字，是一个类
        String nameA="李优秀";

        //布尔值
        boolean flag=false;
        boolean flag1=true;
~~~

### **数据类型拓展**

~~~java
public class Demo02 {
    public static void main(String[] args) {
        //整数拓展 进制 二进制0b 八进制0 十进制 十六进制0x
        int i=10;
        int i1=010; //八进制
        int i2=0x10; //十六进制
        System.out.println(i);
        System.out.println(i1);
        System.out.println(i2);
        System.out.println("===============================================");
        //===============================================
        //浮点数拓展 银行业务
        //BigDecimal 数学工具类
        //===============================================
        //float 有限  离散  舍入误差    大约  接近但不等于
        //double
        //最好不要使用浮点数进行比较
        //最好不要使用浮点数进行比较
        //最好不要使用浮点数进行比较
        float f=0.1f; //0.1
        double d=1.0/10; //0.1
        System.out.println(f==d);
        //System.out.println(f);
        //System.out.println(d);
        float d1=1238972349857f;
        float d2=d1+1;
        System.out.println(d1==d2);
        System.out.println("===============================================");
        //===============================================
        //字符拓展
        //所有字符的本质还是数字
        //编码 Unicode 2字节 65536
        //===============================================
        char c1='a';
        char c2='中';
        System.out.println(c1);
        System.out.println((int)c1);//强制转换
        System.out.println(c2);
        System.out.println((int)c2);//强制转换
        //U0000-UFFFF
        char c3='\u0061';
        System.out.println(c3);
        //转义字符
        //\t 制表
        //\n 换行
        //……………………
        System.out.println("你好\t世界");
        //对象 从内存分析
        System.out.println("===============================================");
        String s1=new String("你好 世界");
        String s2=new String("你好 世界");
        System.out.println(s1==s2);
        String s3="你好 世界";
        String s4="你好 世界";
        System.out.println(s3==s4);
        System.out.println("===============================================");
    }
}

~~~

### 数据类型转换

![](https://pic.imgdb.cn/item/60abcfe41940c48ca73fad4d.png)

~~~java
public class Demo03 {
    public static void main(String[] args) {
        int i=128;
        //强制转换  （类型）变量名 高-->低
        byte b=(byte)i;//内存溢出
        //自动转换 低-->高
        double d=i;
        System.out.println(d);
        System.out.println(i);
        System.out.println(b);
        /* 注意点：
         * 1.不能对布尔值进行转换
         * 2.不能把对象类型转换为不相干的类型
         * 3.在把高容量转换到低容量时，强制转换
         * 4.转换的时候可能存在内存溢出，或者精度问题
         */
        System.out.println("=============================");
        System.out.println((int)23.5);
        System.out.println((int)-45.89f);
        System.out.println("=============================");
        char c='a';
        int d1=c+1;
        System.out.println(d1);
        System.out.println((char)d1);


    }
}
~~~

~~~java
public class Demo04 {
    public static void main(String[] args) {
        //操作比较大的数的时候注意溢出问题
        //JDK7 的新特性 ,数字之间可以用下划线分割
        int money=10_0000_0000;
        System.out.println(money);
        int years=20;
        int total=money*years;
        System.out.println(total);//-1474836480，计算溢出
        long total1=money*years;
        System.out.println(total1);//-1474836480,默认是int转换之前就出现问题
        long total2=money*((long)years);
        System.out.println(total2);//先把一个数转换为long

        //L l
    }
}

~~~

## 变量

~~~java
public class Demo05 {
    //属性：变量

    //实例变量：从属于对象  如果不自行初始化变成默认值
    //布尔值一般为false
    //除了基本类型，其余的默认值为null
    String name;//初始化值一般为null
    int age; //初始化值一般为0

    //类变量 static
    static double salary=2500;

    //main方法
    public static void main(String[] args) {
        // 注重程序可读性
        //局部变量：必须声明和初始化值
        int i=10;
        System.out.println(i);

        //变量类型 变量名字=new Demo05();
        Demo05 demo05 = new Demo05();
        System.out.println(demo05.age);
        System.out.println(demo05.name);

        //类变量
        System.out.println(salary);

    }

    //其他方法
    public void add()
    {
        //System.out.println(i);
    }
}

~~~

## 常量

~~~java
public class Demo06 {
    static final double PI=3.14;
    public static void main(String[] args) {
        //常量 final一般用大写
        System.out.println(PI);
    }
}
~~~

## 运算符

### 算术

单目：~（按位取反）、! (取非)、-（负号运算符）、 ++（自增）、 - -（自减）、

双目：+ - * / %（取余）

三目：a>b?true:false 说明：当a大于b的时候，为true（也就是冒号之前的值），否则为false；这整个[运算符](https://baike.baidu.com/item/运算符)包括一个[关系运算符](https://baike.baidu.com/item/关系运算符)（可以是“>”"<""!="等等），一个“？”，一个“：”，冒号前后需要有两个[表达式](https://baike.baidu.com/item/表达式)或者是值或者是对象。

### 关系

等于符号**:**==，不等于符号**:**!= ，大于符号**:**>， 小于符号**:**<，大于等于符号**:**>= ，小于等于符号**:**<= 。

位与逻辑

位[运算符](https://baike.baidu.com/item/运算符)　与（&）、非（~）、或（|）、异或（^）

&：双目运算符，运算时均把运算数转换为二进制再做比较，规则：当相同的位上均为1时结果为1，否则结 果为0.如：1010&1101，转为二进制：1111110010&10001001101，比较结果为：1000000转为十进制： 64。所以1010&1101=64；

| ：当两边[操作数](https://baike.baidu.com/item/操作数)的位有一边为1时，结果为1，否则为0。如1100|1010=1110

~：0变1,1变0

^：两边的位不同时，结果为1，否则为0.如1100^1010=0110

### [逻辑运算符](https://baike.baidu.com/item/逻辑运算符)

与（&&）、非（!）、或（||）

### 赋值

= += -= *= /= %= &= ^= |= <<= >>=

### instanceof

该[运算符](https://baike.baidu.com/item/运算符)是[双目运算符](https://baike.baidu.com/item/双目运算符)，左面的操作元是一个对象，右面是一个类或接口。当左面的对象是右面的类(或右边类的子孙类)创建的对象、或者是右边接口的实现类(或实现类的子孙类)的对象时，该运算符运算结果是true，否则是false。

### 运算符综述

Java 的[表达式](https://baike.baidu.com/item/表达式)就是用[运算符](https://baike.baidu.com/item/运算符)连接起来的符合Java 规则的式子.运算符的[优先级](https://baike.baidu.com/item/优先级)决定了表达式中运算执行的先后顺序.例如,x<y&&!z相当于(x<y)&&(!z),没有必要去记忆运算符号的优先级别,在编写程序时可尽量的使用括号来实现你想要的运算次序,以免产生难以阅读或含糊不清的计算顺序.运算符的结合性决定了并列相同级别的运算符的先后顺序,例如,加减的结合性是从左到右,8-5+3 相当于(8-5)+3.逻辑否运算符 的结合性是右到左, x 相当于!(!x).表3.4是Java所有运算符的优先级和结合性。

### 位移

<< 带符号左移 >>带符号右移 >>> 无符号右移

### 运算符优先级

按[优先级](https://baike.baidu.com/item/优先级)从高到低排列如下：[ ] ( ) ++ -- ! ～ instanceof * / % + - << >> >>> <> < = > \ == != &^& & || ? := op= 。

~~~java
package operator;

public class Demo01 {
    public static void main(String[] args) {
        int a=10;
        int b=20;
        //字符串连接符 + String 后面会自动转换为字符串
        System.out.println(""+a+b);
        System.out.println(a+b+"");
    }
}
~~~

## 包机制

**包的本质就是文件夹**

![](https://pic.imgdb.cn/item/60ae0b6108f74bc1597d62a0.png)

## JavaDoc

![](https://pic.imgdb.cn/item/60bb42258355f7f718773da4.jpg)

~~~java
package base;

/**
 * @author liyouxiu
 * @version 1.0
 * @since 1.8
 */
public class Doc {
    String name;

    /**
     * @author liyouxiu
     * @param name
     * @return
     * @throws Exception
     */
    public String test(String name) throws Exception
    {
        return name;
    }
}
~~~

~~~bash
#javadoc -encoding UTF-8 -charset UTF-8 Doc.java   --CMDjavadoc生成命令
~~~

### IDEA生成javaDoc

IDEA

1. 在工具栏中找到 tool >> Generate JAVADoc…

![工具栏截图](https://img-blog.csdn.net/20160910175638053)

2. 然后弹出配置窗口

![主配置窗口](https://img-blog.csdn.net/20160910175738836) 
参数说明 
\1. Whole project>>整个项目都生成 
\2. Custom scope>>自定义范围，如下：project files 项目文件，project production files 项目产品文件，project test files 项目的测试文件， 未知范围，class hierarchy 类层 
![选择](https://img-blog.csdn.net/20160910180409757) 
\3. include test source 包含测试目录 
\4. include JDK and … 包含jdk和其他的第三方jar 
\5. link to JDK documentation…链接到JDK api 
\6. output directy 生成的文档存放的位置 
\7. private、package、protected、public 生成文档的级别（类和方法） 
\8. 右边的Generate…是选择生成的文档包含的内容，层级树、导航、索引.. 
\9. 再右边是生成的文档包含的内容信息，作者版本等信息 
\10. Locale 语言类型,zh-CN 
\11. Other command line arguments 其他参数 
\12. Maximum heep… 最大堆栈

## java流程控制（输入）

![](https://pic.imgdb.cn/item/60cdf7aa844ef46bb28d91a7.jpg)

![](https://pic.imgdb.cn/item/60cdfdfe844ef46bb2d1a2bf.jpg)

**next**

~~~java
package com.Scaner;

import java.util.Scanner;

public class Demo01 {
    public static void main(String[] args) {
        //创建一个扫描器对象，用于接受数据
        Scanner scanner = new Scanner(System.in);
        System.out.println("使用next方式接收：");
        //判断用户有没有输入字符串
        if (scanner.hasNext())
        {
            //使用next方式接收
            String str=scanner.next();
            System.out.println("输出的是："+str);
        }
        //凡是属于IO流的类用完之后要关闭，如果不关闭会一直占用资源，要养成好习惯
        scanner.close();
    }
}
~~~

**nextLine**

~~~java
package com.Scaner;

import java.util.Scanner;

public class Demo02 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("使用nextLine进行输入");
        //判断是还有输入
        if(scanner.hasNext())
        {
            String str=scanner.nextLine();
            System.out.println("输出的是："+str);
        }
        scanner.close();
    }
}

~~~

~~~java
package com.Scaner;

import java.util.Scanner;

public class Demo03 {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int i=0;
        float f=0.0f;
        //判断输入的是否为整数
        System.out.println("请输入一个整数");
        if (scanner.hasNextInt()) {
             i = scanner.nextInt();
            System.out.println("输入的是"+i);
        }
        else {
            System.out.println("输入有误");
        }
        System.out.println("请输入小数");
        if (scanner.hasNextFloat()) {
            f = scanner.nextFloat();
            System.out.println("输入的是"+f);
        }
        else {
            System.out.println("输入有误");
        }

        scanner.close();
    }
}
~~~

~~~java
package com.Scaner;

import java.util.Scanner;

public class Demo04 {
    public static void main(String[] args) {
        //输入多个数字，并求总和和平均值
        Scanner scanner=new Scanner(System.in);

        //总和
        double sum=0;
        //数字个数
        int i=0;
        System.out.println("请输入数字");
        while(scanner.hasNextDouble()) {
            double v = scanner.nextDouble();
            sum+=v;
            i++;
        }
        System.out.println("总和为"+sum+"平均值为"+sum/i);
    }
~~~

## 结构

### 顺序

顺序执行

### 选择

#### **if-----else**

~~~java
package com.Struct;

import java.util.Scanner;

public class IfDemo01 {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        //equals:判断字符串是否相等
        String s=scanner.nextLine();
        if(s.equals("Hello"))
        {
            System.out.println(s);
        }

        System.out.println("End");

        scanner.close();
    }
}
~~~

~~~java
package com.Struct;

import java.util.Scanner;

public class IfDemo02 {
    public static void main(String[] args) {
        //考试分数大于60及格，小于60不及格
        Scanner scanner=new Scanner(System.in);
        System.out.println("请输入你的分数");
        float score=scanner.nextFloat();
        //score:分数
        if(score>=60) {
            System.out.println("及格");
        }
        else {
            System.out.println("不及格");
        }
        scanner.close();
    }
}
~~~

~~~JAVA
package com.Struct;

import java.util.Scanner;

public class IfDemo03 {
    public static void main(String[] args) {
        /**
         * 成绩判断
         */
        Scanner scanner=new Scanner(System.in);
        System.out.println("请输入成绩");
        int score = scanner.nextInt();
        if(score==100){
            System.out.println("恭喜！满分");
        }
        else if (score>=90&&score<100){
            System.out.println("A级");
        }
        else if (score>=80&&score<90){
            System.out.println("B级");
        }
        else if (score>=70&&score<80){
            System.out.println("C级");
        }
        else if (score>=60&&score<70){
            System.out.println("D级");
        }
        else if (score>=0&&score<60){
            System.out.println("不及格");
        }
        else {
            System.out.println("成绩不合法");
        }

        scanner.close();
    }
}
~~~

#### **switch**

~~~java
package com.Struct;

public class SwitchDemo01 {
    public static void main(String[] args) {
        //case:穿透   switch：匹配具体的值
        char c='B';
        switch(c){
            case 'A':
                System.out.println("优秀");
                break;
            case 'B':
                System.out.println("良好");
                break;
            case 'C':
                System.out.println("及格");
                break;
            default:
                System.out.println("不及格");
        }

    }
}
~~~

~~~java
package com.Struct;

public class SwitchDemo02 {
    public static void main(String[] args) {
        String name="李优秀";

        //JDK7之后才支持可以匹配字符串
        //字符的本质还是数字

        //利用IDEA反编译
        switch(name)
        {
            case "李良好":
                System.out.println("李良好");
                break;
            case "李优秀":
                System.out.println("李优秀");
                break;
            default:
                System.out.println(name);

        }
    }
}
~~~

### 循环

#### for

~~~java
package com.Struct;

public class ForDemo01 {
    public static void main(String[] args) {
        //输出1-100
        //初始化；条件判断；迭代
        for (int i=1;i<=100;i++)
        {
            System.out.println(i);
        }

    }
}
~~~

~~~java
package com.Struct;

public class ForDemo02 {
    public static void main(String[] args) {
        //计算1-100的奇数和偶数的和
        int ji=0,ou=0;
        for (int i = 0; i <=100; i++) {
            if(i%2==0) {
                ou+=i;
            }
            else {
                ji+=i;
            }

        }
        System.out.println("奇数的和是"+ji+"偶数的和是"+ou);
    }
}
~~~

~~~java
package com.Struct;

public class ForDemo03 {
    public static void main(String[] args) {
        //输出0-1000之间能被5整除的数，每行输出三个
        int sum=0;//计数
        for (int i = 0; i <= 1000; i++) {
            if(i%5==0){
                System.out.print(i+" ");// \t 制表符
                sum++;
                if (sum%3==0){
                    System.out.println();
                    // System.out.print("\n"); \n 换行
                }
            }
        }
        //println 输出之后换行
        //print   输出之后不会换行
    }
}
~~~

~~~java
package com.Struct;

public class ForDemo04 {
    public static void main(String[] args) {
        //打印九九乘法表
        for (int i = 1; i <=9; i++) {
            for (int i1 = 1; i1 <=i; i1++) {
                System.out.print(i+"*"+i1+"="+i*i1+"\t");
            }
            System.out.println();
        }
    }
}
~~~

~~~java
package com.Struct;

public class ForDemo05 {
    public static void main(String[] args) {
        //增强for循环
        int[] numbers={10,20,30,40};//数组
        //遍历数组的元素
        for (int x:numbers){
            System.out.println(x);
        }
    }
}
~~~

#### while

~~~java
package com.Struct;

public class WhileDemo01 {
    public static void main(String[] args) {
        //输出1-100
        int i=1;
        while(i<=100){
            System.out.println(i);
            i++;
        }
    }
}
~~~

~~~java
package com.Struct;

public class WhileDemo02 {
    public static void main(String[] args) {
        //计算1-100的和
        int i=1,sum=0;

        while(i<=100){
            sum+=i;
            i++;
        }
        System.out.println(sum);
    }
}
~~~

~~~java
package com.Struct;

public class WhileDemo03 {
    public static void main(String[] args) {
        //输出0-1000之间能被5整除的数，每行输出三个
        int i=0;//0-1000
        while(i<=1000){
            if(i%5==0){
                System.out.print(i+" ");
            }
            if (i%15==0){
                System.out.println();
            }
            i++;
        }
    }

}
~~~

#### do---while

~~~java
package com.Struct;

public class DoWhileDemo01 {
    public static void main(String[] args) {
        int i=0;
        int sun=0;
        do {
            sun+=i;
            i++;
        }while(i<=100);
        System.out.println(sun);
        //Do-While至少执行一次
    }

}
~~~

## 方法

![](https://pic.imgdb.cn/item/60ddb93a5132923bf853c533.jpg)

~~~java
package com.method;

public class Demo01 {
    //main方法
    public static void main(String[] args) {
        int sum = add(1, 2);  //实际参数：实际调用传递的参数
        System.out.println(sum);
//        test();
    }
    //加法
    //形式参数：定义参数
    public static int add(int a,int b){
        return a+b;
    }
    public static void test()
    {
        int sum=0;//计数
        for (int i = 0; i <= 1000; i++) {
            if(i%5==0){
                System.out.print(i+" ");// \t 制表符
                sum++;
                if (sum%3==0){
                    System.out.println();
                    // System.out.print("\n"); \n 换行
                }
            }
        }
    }
}
~~~

~~~java
package com.method;

public class Demo02 {
    public static void main(String[] args) {
//        int max = max(3, 4);
        int max = max(3, 3);
        System.out.println(max);
    }
    //比较大小
    //方法一
//    public static int max(int a,int b){
//        if(a>b){
//            return a;
//        }
//        else {
//            return b;
//        }
//    }
    //方法二
    public static int max(int a,int b){
        int result=-1; //初始化
        if (a==b){
            System.out.println("两数相等");
            return 0; //终止方法
        }
        if(a>b){
            result=a;
        }else {
            result=b;
        }

        return result;
    }
}
~~~

~~~java
package com.method;

public class Demo03 {
    public static void main(String[] args) {
        //数组长度 args.length
        for (int i = 0; i <args.length ; i++) {
            System.out.println(args[i]);
        }
    }
}
~~~

~~~java
package com.method;

public class Demo04 {
    public static void main(String[] args) {
        Demo04 demo04 = new Demo04();
        demo04.test(1,2,3,4);
    }
    //可变参数 :未知参数的个数
    public void test(int ... i)
    {
        System.out.println(i[0]);
        System.out.println(i[1]);
        System.out.println(i[2]);
        System.out.println(i[3]);
    }
}
~~~

~~~java
package com.method;

public class Demo05 {
    public static void main(String[] args) {
        Demo05 demo05 = new Demo05();
        demo05.test();
    }
    public void test()
    {
        test();
    }
}
~~~

~~~java
package com.method;
//递归思想：但是尽量少用递归
public class Demo06 {
    public static void main(String[] args) {
        //阶乘
        int i = 5;
        System.out.println(f(i));

    }
    //5! 5*4*3*2*2*1
    public static int f(int n)
    {
        if(n==1){
            return 1;
        }else {
            return n*f(n-1);
        }
    }
}
~~~

## 数组

~~~java
package com.Array;

public class ArrayDemo01 {
    public static void main(String[] args) {
        //定义有两种方法
        //1.首先选用
        int[] num;
        //2.
        int num2[];

        //使用new方法定义数组，开辟空间
        num = new int[10]; //存放10个int类型的数
        //给数组赋值
        num[0]=1;
        num[1]=2;
        num[2]=3;
        num[3]=4;
        num[4]=5;
        num[5]=6;
        num[6]=7;
        num[7]=8;
        num[8]=9;
        num[9]=10;
        int sum =0;
        //计算所有元素的和
        for (int i = 0; i < 10; i++) {
            sum +=num[i];
        }
        System.out.println(num[3]);
        System.out.println(num.length); //获取数组的长度
        System.out.println(sum);

    }
}
~~~

~~~java
package com.Array;

import com.sun.xml.internal.ws.addressing.WsaActionUtil;

public class ArrayDemo03 {
    public static void main(String[] args) {
        int[] a={1,2,3,4,5};

        //打印数组元素
        for (int i = 0; i < a.length; i++) {
            System.out.println(a[i]);
        }
        System.out.println("=====================");

        //计算所有元素的和
        int sum=0;
        for (int i = 0; i < a.length; i++) {
            sum+=a[i];
        }
        System.out.println("数组的和是："+sum);
        System.out.println("=====================");
        //寻找最大的数
        int max=a[0];
        for (int i = 0; i <a.length ; i++) {
            if(a[i]>max){
                max=a[i];
            }
        }
        System.out.println("最大的数是："+max);
    }
}
~~~

~~~java
package com.Array;

public class ArrayDemo04 {
    public static void main(String[] args) {
        //增强for循环
        int[] a={1,2,3,4,5};
        //增强for循环,JDK1.5以后没有下标
//        for (int i : a) {
//            System.out.println(i);
//        }
        PrintArray(a);
        System.out.println();
        System.out.println("===============================");
        int[] b=reverse(a);
        for (int i : b) {
            System.out.print(i+" ");
        }
    }
    //数组打印方法
    public static void PrintArray(int[] a){
        for (int i : a) {
            System.out.print(i+" ");
        }
    }
    //数组反转
    public static int[] reverse(int[] a){
        int[] rev=new int[a.length];
        //数组反转
        int b=0;
        for (int i = a.length-1; i >=0 ; i--) {
            rev[b++]=a[i];
        }

        return rev;
    }
}
~~~

~~~java
package com.Array;

import java.util.Arrays;

public class ArraysDemo06 {
    public static void main(String[] args) {
        int[] a={1,5,6,7,34,5,67,345};
        System.out.println(a);//[I@4554617c
        //打印数组元素
        System.out.println(Arrays.toString(a));
        System.out.println("==========================");
        //Print(a);

        //排序
        Arrays.sort(a);
        System.out.println(Arrays.toString(a));
        System.out.println("==========================");

        //填充
        Arrays.fill(a,0);
        System.out.println(Arrays.toString(a));
    }
    //不要重复造轮子
    public static void Print(int[] a){
        for (int i = 0; i <a.length ; i++) {
            if (i==0){
                System.out.print("[");
            }
            if(i==a.length-1){
                System.out.print(a[i]+"]");
            }else {
                System.out.print(a[i]+", ");
            }

        }
    }
}
~~~

~~~java
package com.Array;

import java.util.Arrays;

//冒泡排序
/*
* 数组排序
* */
public class ArraysDemo07 {
    public static void main(String[] args) {
        int[] a={12,3,4,5,6,788,23,4,67};
        System.out.println(Arrays.toString(a));
        sort(a);
        System.out.println(Arrays.toString(a));
    }
    //逻辑
    //1.比较数组两个元素
    //2.每一次比较都选出最大的一个或者最小的一个数字
    //3.下一次少比较一次
    //4.依次循环直至数组结束
    public static int[] sort(int[] arrays){
        //临时变量
        int t;
        //外层循环，判断要走多少次
        for (int i = 0; i <arrays.length-1 ; i++) {
            //内层循环，交换位置，如果第一个数字比第二个数字大进行位置交换
            for (int j = 0; j <arrays.length-1-i ; j++) {
                if (arrays[j]>arrays[j+1]) {
                    t=arrays[j];
                    arrays[j]=arrays[j+1];
                    arrays[j+1]=t;
                }
            }
        }
        return arrays;
    }
}
~~~

~~~java
package com.Array;

import java.util.Arrays;

public class ArraysDemo08 {
    public static void main(String[] args) {
        //稀疏数组

        //1.创建棋盘 0：没有棋子 ，1：黑棋 ，2：白棋
        int[][] a=new int[11][11];
        a[1][2]=1;
        a[2][3]=2;
        //输出原始数组
        System.out.println("输出原始数组");
        for (int[] ints : a) {
            for (int anInt : ints) {
                System.out.print(anInt+"\t");
            }
            System.out.println();
            }
        System.out.println("===================================================");
        //1.转换为稀疏数组保存
        //获取有效值的个数
        int sum=0;
        for (int i = 0; i <11 ; i++) {
            for (int j = 0; j <11 ; j++) {
                if (a[i][j]!=0){
                    sum++;
                }
            }
        }
        System.out.println("有效值的个数"+sum);
        //2.创建稀疏数组
        int[][] a2=new int[sum+1][3];
        a2[0][0]=11;
        a2[0][1]=11;
        a2[0][2]=sum;
        //遍历二维数组，将值存放在稀疏数组中
        int count=0;
        for (int i = 0; i <a.length ; i++) {
            for (int j = 0; j <a[i].length ; j++) {
                if(a[i][j]!=0){
                    count++;
                    a2[count][0]=i;
                    a2[count][1]=j;
                    a2[count][2]=a[i][j];

                }
            }
        }
        //输出稀疏数组
        System.out.println("稀疏数组");
        for (int[] ints : a2) {
            for (int anInt : ints) {
                System.out.print(anInt+"\t");
            }
            System.out.println();
        }
        System.out.println("===================================================");
        //还原稀疏数组
        System.out.println("还原稀疏数组");
        int[][] a3=new int[a2[0][0]][a2[0][1]];
        //还原值
        for (int i = 1; i < a2.length ; i++) {
            a3[a2[i][0]][a2[i][1]]=a2[i][2];
        }
        System.out.println("打印还原稀疏数组");
        for (int[] ints : a3) {
            for (int anInt : ints) {
                System.out.print(anInt+"\t");
            }
            System.out.println();
        }
        }
    
    }

~~~

## 面向对象（oop）

### 初识面向对象（概念抽象）

![](https://pic.imgdb.cn/item/610a6b7a5132923bf8d53bb6.jpg)

![![](https://pic.imgdb.cn/item/610cd4265132923bf8a6917d.jpg)](https://pic.imgdb.cn/item/610a71225132923bf8e54e01.jpg)

**以类的方式组织代码，以对象的形式组织数据**

~~~java
package OOP.Demo01;

public class Demo02 {
    public static void main(String[] args) {
        //实例化 new
        //对象类型 对象名=对象值
        Student student = new Student();
        student.say();
    }
    //static和类一起加载的
    public static void a(){
       // b();
    }
    //类实例化之后才存在的
    public void b(){

    }
}
~~~

~~~java
package OOP.Demo01;
//引用传递 对象 本质还是值传递
public class Demo05 {
    public static void main(String[] args) {
        Person person = new Person();
        System.out.println(person.name);
        Demo05.change(person);
        System.out.println(person.name);
    }
    public static void change(Person person){
        //person是一个对象 指向的是---->Person类 Person person = new Person(); 是一个具体的对象 可以改变属性
        person.name="李优秀";
    }
}
//定义了一个Person类 有个属性name
class Person{
    String name;//null
}
~~~

~~~java
package OOP.Demo01;
//学生类
public class Student {
    //静态方法
//    public static void say(){
//        System.out.println("学生说话了");
//    }
    //非静态方法
    public void say(){
        System.out.println("学生说话了");
    }
}
~~~

### 内存分析

![](https://pic.imgdb.cn/item/610d431d5132923bf8c068c2.jpg)

~~~java
package OOP.Demo02;
//一个项目应该只存在一个main方法
public class Application {

}
~~~

~~~java
package OOP.Demo02;
//java文件----->class文件
public class Person {
    //一个类什么都不写也会存在一个方法
    //显示的定义构造器
    String name;
    int age;
    //实例化初始值
    //1.使用new关键字必须要有构造器，本质是调用构造器
    //2.初始化值

    //alt+insert 生成构造器
    public Person(String name) {
        this.name = name;
    }

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
/*
* public static void main(String[] args) {
        //new 实例化了一个对象
        Person person = new Person("nihao");
        System.out.println(person.name);
    }
    构造器
    1.和类名相同
    2.无返回值
    作用：
    1.new 本质在调用构造方法
    2.初始化对象的值
    注意点：
    1.定义有参构造之后，如果想使用无参构造，必须定义一个无参构造
* */
~~~

~~~java
package OOP.Demo02;
//学生类
public class Student {
    //属性：字段
    String name;//null
    int age;//0
    //方法
    public void study(){
        System.out.println(this.name+"在学习");
    }
}
/*测试
public static void main(String[] args) {
        //类是抽象的，需要实例化
        //类实例化后会返回一个实例化的对象
        //student对象就是Student的一个具体实例
        Student xiaoming = new Student();
        Student xiaohong = new Student();
        xiaoming.name="小明";
        System.out.println(xiaoming.name);
        System.out.println(xiaoming.age);
        xiaoming.study();
    }
* */
~~~

~~~java
package OOP.Demo03;

public class Application {
    public static void main(String[] args) {
        Pet dog = new Pet();
        dog.name="旺财";
        dog.age=3;
        dog.shout();
        System.out.println(dog.name);
        System.out.println(dog.age);
    }
}
/*1.类与对象
        类是一个模板：抽象 对象是一个具体的实例

  2.方法
         定义，调用

  3.对应的引用
         对象是通过引用来操作的：栈-->堆

  4.属性：字段filed 成员变量
   默认初始化
   数字：0
   char：u0000
   boolean：false
   引用：null
   修饰符 属性类型 属性名=属性值！

   5.对象的创建和使用
   -必须使用new关键字创造对象  构造器Pet dog = new Pet();
   -对象的属性   dog.name
   -对象的方法   dog.shout();

   6.类
   静态的属性 属性

    封装 继承 多态
*
*
* */

~~~

### 三大特征（封装，继承，多态）

**高内聚，低耦合**

#### 封装

~~~java
package OOP.Demo04;

public class Application {
    public static void main(String[] args) {
        Student student = new Student();
        student.setName("liyouxiu");
        System.out.println(student.getName());
        student.setAge(999);
        System.out.println(student.getAge());
    }
}
~~~

~~~java
package OOP.Demo04;
//类
public class Student {
    //属性私有
    private String name;//名字
    private int id;//学号
    private char sex;//性别
    private int age;//年龄
    //提供一些可以操作这个属性的方法！
    //提供一些public的get，set方法
    //get 获得这个数据
    public String getName(){
        return this.name;
    }
    //set 设置值
    public void setName(String name){
        this.name=name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public int getAge() {
        return age;
    }
    /*
    * 1.提高程序的安全性，保护数据
    * 2.隐藏代码实现细节
    * 3.统一接口
    * 4.系统的可维护性
    * */
    public void setAge(int age) {
        if(age>120||age<0){
            System.out.println("数据输入有误");
        }
        else{
            this.age = age;
        }
    }
    //学习（）
    //睡觉（）



}
~~~

#### 继承

```
super注意点：
    1.super调用父类的构造方法，必须在构造方法的第一个
    2.super必须只能出现在子类方法或者构造方法中
    3.super和this不能同时调用构造方法
VS this：
    代表对象不同：
        this：本身调用者这个对象
        super：代表父类对象的应用
    前提：
        this：没有继承也能使用
        super：只能在继承条件下使用
    构造方法
        this();本类构造
        super();父类构造

重写：需要有继承的关系：子类重写父类的方法！
    1.方法名必须相同
    2.参数列表必须相同
    3.修饰符：范围可以扩大  public>protected>default>private
    4.抛出的异常：范围可以被缩小，不可以扩大
重写：子类的方法和父类必须一致；方法体不同
为什么需要重写
    1.父类的功能，子类不一定需要，或者不一定满足
    2.
```

~~~java
package OOP.Demo05;
//继承
public class A extends B{
    //Override 重写
    @Override//注解：有功能的注释
    public void test() {
        System.out.println("A=>test");
    }
}

~~~

~~~java
package OOP.Demo05;

public class Application {
    //静态方法和非静态方法区别较大
    public static void main(String[] args) {
        //静态方法：方法的调用只和左边，定义的数据类型有关
        //非静态：重写
        A a = new A();
        a.test();//A

        //父类的引用指向了子类
        B b=new A();//子类重写了父类的方法
        b.test();//B
    }
}

~~~

~~~java
package OOP.Demo05;
//重写都是方法的重写，与属性无关
public class B {
    public  void test()
    {
        System.out.println("B=>test");
    }
}

~~~

~~~java
package OOP.Demo05;
//人 person :父类 基类
//在java中所有的类都默认直接或间接继承Object
public class Person {
    //public
    //private

    public Person(String name) {
        System.out.println("Person无参");
    }
    public Person() {
        System.out.println("Person无参");
    }

    public int money=10_0000_0000;
    protected String name="liyouxiu";
    public void print(){
        System.out.println("Person");
    }
    public void say(){
        System.out.println("说了一句话");
    }
}
~~~

~~~java
package OOP.Demo05;
//学生是人 派生类 ，子类
//子类继承了父类 就会拥有父类的全部的方法
public class Student extends Person{
    //隐藏代码 调用了父类的无参构造
    public Student() {
        super("hello");//隐藏的代码 调用父类的构造器必须放在子类构造器第一行
        // this("hello");
        System.out.println("Student无参");

    }



    private String name="liwei";
    public void test(String name){
        System.out.println(name);
        System.out.println(this.name);
        System.out.println(super.name);
    }
    public void print(){
        System.out.println("Student");
    }
    public void test1(){
        print();
        this.print();
        super.print();
    }
}
//       Student student = new Student();
//        student.say();
//        System.out.println(student.money);
//        student.test("lwl");
//        System.out.println("======================================");
//        student.test1();
~~~

~~~java
package OOP.Demo05;
//Teacher is 人 派生类 ，子类
public class Teacher extends Person{
}
~~~

#### 多态

~~~java
package OOP.Demo06;

public class Application {
    public static void main(String[] args) {
        //类型转换
        //高                     低
        Person person = new Student();
        //person转换为Student类型就可以使用
//        Student person1 = (Student) person;
//        person1.go();
        //子类转换为父类可能会丢失一些方法
        ((Student) person).go();


    }
}
//    //一个对象的实际类型是确定的
//
//
//    //可以指向的引用类型不确定,父类的引用指向子类
//    //Student能的调用的方法只有自己的或者父类的
//    Student s1 = new Student();
//    //Person不能调用子类的方法
//    Person s2 = new Student();
//    Object s3= new Student();
//        s2.run();//子类重写了父类的方法。执行子类的方法
//                s1.run();
//                //对象能执行那些方法。主要看左边的类型，和右边关系不大
//                s1.eat();
//                ((Student) s2).eat();//类型转换

/*1.父类引用指向子类对象
2.把子类转换为父类向上转型
3.把父类转换为子类强制转型（可能会丢失精度）
4.方便方法的调用，减少重复的代码

封装 继承 多态
*
*
*
*
*
* */
~~~

~~~java
package OOP.Demo06;

public class Person {
    public void run(){
        System.out.println("run");
    }
}
/*
* 多态注意事项
*   1.多态是方法的多态，属性没有多态
*   2.父类和子类有联系（类型转换异常【ClassCastException】）
*   3.存在的条件：继承关系，方法需要重写，父类引用指向子类对象！father f1=new son；
*       不能重写的
*       1.static ：方法，属于类，他不属于实例
*       2.final  ：常量
*       3.private ：私有的不能重写
*
*
* */
//Object object = new Student();
////Object->Person->Student
////Object->Person->Teacher
////Object->String
//        System.out.println(object instanceof Student);
//                System.out.println(object instanceof Person);
//                System.out.println(object instanceof Object);
//                System.out.println(object instanceof Teacher);
//                System.out.println(object instanceof String);
//                System.out.println("=======================================");
//                Person person = new Student();
//                System.out.println(person instanceof Student);
//                System.out.println(person instanceof Person);
//                System.out.println(person instanceof Object);
//                System.out.println(person instanceof Teacher);
//                //System.out.println(person instanceof String); 编译错误
//                System.out.println("=======================================");
//                Student student = new Student();
//                System.out.println(student instanceof Student);
//                System.out.println(student instanceof Person);
//                System.out.println(student instanceof Object);
////        System.out.println(student instanceof Teacher);编译错误
////        System.out.println(student instanceof String);编译错误
////System.out.println(x instanceof y);  能不能通过编译主要是通过是否存在父子关系
~~~

~~~JAVA
package OOP.Demo06;

public class Student extends Person{
//    @Override
//    public void run() {
//        System.out.println("son");
//    }
//    public void eat(){
//        System.out.println("eat");
//    }
    public void go() {
        System.out.println("go");
    }
}
~~~

~~~java
package OOP.Demo06;

public class Teacher extends Person{

}
~~~

### static关键字

~~~java
package OOP.Demo07;
//静态导入包
import static java.lang.Math.random;
import static java.lang.Math.PI;

public class Test {
    public static void main(String[] args) {
        System.out.println(random());
        System.out.println(PI);
    }
}
~~~

~~~java
package OOP.Demo07;

public final class Person {
    //2.赋初始值
    {
        //代码块（匿名代码块）
        System.out.println("匿名代码块");

    }
    //1.只执行一次
    static {
        //静态代码块
        System.out.println("静态代码块");
    }
    //3
    public Person() {
        System.out.println("构造方法");
    }

    public static void main(String[] args) {
        Person person = new Person();
        System.out.println("===============================");
        Person person1 = new Person();
    }
}
~~~

~~~java
package OOP.Demo07;
//static
public class Student{
    private static int age;//静态变量 多线程
    private double score;//非静态变量
    public void run(){
        go();
    }
    public static void go(){

    }
    public static void main(String[] args) {
//        Student s1 = new Student();
//        System.out.println(Student.age);
//        //System.out.println(Student.score);
//        System.out.println(s1.age);
//        System.out.println(s1.score);
       new Student().run();
       go();
    }
}
~~~

### 抽象类

![](https://pic.imgdb.cn/item/61151bb65132923bf831b04e.jpg)

~~~java
package OOP.Demo08;
//抽象类的所有方法，继承了他的子类，都必须要实现他的所有方法
public class A extends Action{
    @Override
    public void DoSomeThing() {

    }
}
~~~

~~~java
package OOP.Demo08;
//抽象类 abstract  extends：类单继承  （接口可以实现多继承）
public abstract class Action {
    //约束~有人帮我们实现
    //抽象方法 只有方法名字，没有方法体
    public abstract void DoSomeThing();
    //1.不能new这个抽象类，只能子类实现他 约束
    //2.抽象类中可以写普通方法
    //3.抽象方法必须写在抽象类中
    //抽象的抽象

}
~~~

~~~java
package OOP.Demo08;

public class Application {
    public static void main(String[] args) {

    }
}
~~~

### 接口

![](https://pic.imgdb.cn/item/61151f275132923bf838ecdd.jpg)

```
接口作用
    1.约束
    2.定义一些方法，让不同的人实现
    3.public abstract（方法）
    4.public abstract final（常量）
    5.接口不能被实例化~，接口中没有构造方法
    6.implements可以实现多个接口
    7.必须重写接口中的方法
```

~~~java
package OOP.Demo09;

public interface TimeService {
    void timr();
}
~~~

~~~java
package OOP.Demo09;
//接口 interface 接口都需要实现类完成
public interface UserService {
    //接口中的方所有定义都是public
    void add(String name);
    void delete(String name);
    void update(String name);
    void query(String name);
}
~~~

~~~java
package OOP.Demo09;
//Impl 一般为接口实现类       implements实现接口
//实现了接口 必须实现他的方法
public class UserServiceImpl implements UserService,TimeService{
    //利用接口实习多继承
    @Override
    public void add(String name) {

    }

    @Override
    public void delete(String name) {

    }

    @Override
    public void update(String name) {

    }

    @Override
    public void query(String name) {

    }

    @Override
    public void timr() {

    }
}
~~~

### 内部类

~~~java
package OOP.Demo10;

public class Application {
    public static void main(String[] args) {
        //new
        Outer outer = new Outer();

        //通过外部类实现内部类方法
        Outer.inner inner = outer.new inner();
        inner.getID();
    }
}
~~~

~~~java

~~~

```
package OOP.Demo10;
public class Outer {
    private int id=10;
    public void out(){
        System.out.println("这是外部类的方法");
    }
    public class inner{
        public void in(){
            System.out.println("这是内部类方法");
        }
        //获得内部类的私有属性
        public  void getID(){
            //System.out.println(id);
        }
    }
    //局部内部类
    public void test(){
        class inner{

        }
    }
}
```

## 异常

![](https://pic.imgdb.cn/item/611674455132923bf8ba68d4.jpg)

![](https://pic.imgdb.cn/item/61167d9a5132923bf8e9db17.jpg)

![](https://pic.imgdb.cn/item/61167e5d5132923bf8ee322e.jpg)

![](https://pic.imgdb.cn/item/61167eb85132923bf8f03ffc.jpg)

![](https://pic.imgdb.cn/item/61167efc5132923bf8f1c423.jpg)

![](https://pic.imgdb.cn/item/61167fbb5132923bf8f5f41d.jpg)

![](https://pic.imgdb.cn/item/6116857f5132923bf817480a.jpg)

![](https://pic.imgdb.cn/item/611693225132923bf86c9838.jpg)

~~~java
package Exception;

public class Test {
    public static void main(String[] args) {
            new Test().test(1,0);


    }
    public void a(){b();};
    public void b(){a();};
    //假设这个方法处理不了这个异常，可以在方法上抛出异常
    public void test(int a,int b) throws ArithmeticException{
        if(b==0){
            throw new ArithmeticException();//主动抛出异常,一般在方法中使用
        }
        System.out.println(a/b);
    }
}
/*
        int a=1;
        int b=0;
 try {//try监控区域
            if(b==0){
                throw new ArithmeticException();//主动抛出异常
            }
            System.out.println(a/b);
//            new Test().a();
        }catch (Throwable e){//catch(想要捕获的异常类型) 捕获异常
            System.out.println("程序出现异常，b不能为0");
        }finally {//finally处理善后工作
            System.out.println("finally");
        }
        //可以不要finally 假设IO，资源关闭
 */
~~~

~~~java
package Exception;

public class Test2 {
    public static void main(String[] args) {
        int a=1;
        int b=0;
        //ctrl+alt+T
        try {
            System.out.println(a/b);
        } catch (Exception e) {
            e.printStackTrace(); //打印错误的栈信息
        } finally {
        }
    }
}
~~~

~~~java
package Exception.Demo02;

public class MyException extends Exception{
    private int detail;

    public MyException(int a) {
        this.detail=a;
    }

    //异常的打印信息
    @Override
    public String toString() {
        return "MyException{" +
                "detail=" + detail +
                '}';
    }
}
~~~

~~~java
package Exception.Demo02;

public class Test {
    //可能会存在异常的方法
    static void test(int a) throws MyException{
        System.out.println("传递的参数为"+a);
        if(a>10){
            throw new MyException(a);//抛出
        }
        System.out.println("ok");
    }

    public static void main(String[] args) {
        try {
            test(11);
        } catch (MyException e) {
            //e.printStackTrace();
            System.out.println("MyException=>"+e);
        }
    }
}
~~~

